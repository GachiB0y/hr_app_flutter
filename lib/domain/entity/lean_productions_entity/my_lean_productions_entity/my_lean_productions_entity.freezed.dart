// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_lean_productions_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

MyLeanProductionsEntity _$MyLeanProductionsEntityFromJson(
    Map<String, dynamic> json) {
  return _MyLeanProductionsEntity.fromJson(json);
}

/// @nodoc
mixin _$MyLeanProductionsEntity {
  DateTime get date => throw _privateConstructorUsedError;
  String get number => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;
  String get issue => throw _privateConstructorUsedError;
  String get solution => throw _privateConstructorUsedError;
  String get expenses => throw _privateConstructorUsedError;
  String get benefit => throw _privateConstructorUsedError;
  List<ImplementsForLeanProdInfo> get implementers =>
      throw _privateConstructorUsedError;
  List<FileElement> get files => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MyLeanProductionsEntityCopyWith<MyLeanProductionsEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyLeanProductionsEntityCopyWith<$Res> {
  factory $MyLeanProductionsEntityCopyWith(MyLeanProductionsEntity value,
          $Res Function(MyLeanProductionsEntity) then) =
      _$MyLeanProductionsEntityCopyWithImpl<$Res, MyLeanProductionsEntity>;
  @useResult
  $Res call(
      {DateTime date,
      String number,
      String status,
      String issue,
      String solution,
      String expenses,
      String benefit,
      List<ImplementsForLeanProdInfo> implementers,
      List<FileElement> files});
}

/// @nodoc
class _$MyLeanProductionsEntityCopyWithImpl<$Res,
        $Val extends MyLeanProductionsEntity>
    implements $MyLeanProductionsEntityCopyWith<$Res> {
  _$MyLeanProductionsEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
    Object? number = null,
    Object? status = null,
    Object? issue = null,
    Object? solution = null,
    Object? expenses = null,
    Object? benefit = null,
    Object? implementers = null,
    Object? files = null,
  }) {
    return _then(_value.copyWith(
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      number: null == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      issue: null == issue
          ? _value.issue
          : issue // ignore: cast_nullable_to_non_nullable
              as String,
      solution: null == solution
          ? _value.solution
          : solution // ignore: cast_nullable_to_non_nullable
              as String,
      expenses: null == expenses
          ? _value.expenses
          : expenses // ignore: cast_nullable_to_non_nullable
              as String,
      benefit: null == benefit
          ? _value.benefit
          : benefit // ignore: cast_nullable_to_non_nullable
              as String,
      implementers: null == implementers
          ? _value.implementers
          : implementers // ignore: cast_nullable_to_non_nullable
              as List<ImplementsForLeanProdInfo>,
      files: null == files
          ? _value.files
          : files // ignore: cast_nullable_to_non_nullable
              as List<FileElement>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MyLeanProductionsEntityCopyWith<$Res>
    implements $MyLeanProductionsEntityCopyWith<$Res> {
  factory _$$_MyLeanProductionsEntityCopyWith(_$_MyLeanProductionsEntity value,
          $Res Function(_$_MyLeanProductionsEntity) then) =
      __$$_MyLeanProductionsEntityCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {DateTime date,
      String number,
      String status,
      String issue,
      String solution,
      String expenses,
      String benefit,
      List<ImplementsForLeanProdInfo> implementers,
      List<FileElement> files});
}

/// @nodoc
class __$$_MyLeanProductionsEntityCopyWithImpl<$Res>
    extends _$MyLeanProductionsEntityCopyWithImpl<$Res,
        _$_MyLeanProductionsEntity>
    implements _$$_MyLeanProductionsEntityCopyWith<$Res> {
  __$$_MyLeanProductionsEntityCopyWithImpl(_$_MyLeanProductionsEntity _value,
      $Res Function(_$_MyLeanProductionsEntity) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
    Object? number = null,
    Object? status = null,
    Object? issue = null,
    Object? solution = null,
    Object? expenses = null,
    Object? benefit = null,
    Object? implementers = null,
    Object? files = null,
  }) {
    return _then(_$_MyLeanProductionsEntity(
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      number: null == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      issue: null == issue
          ? _value.issue
          : issue // ignore: cast_nullable_to_non_nullable
              as String,
      solution: null == solution
          ? _value.solution
          : solution // ignore: cast_nullable_to_non_nullable
              as String,
      expenses: null == expenses
          ? _value.expenses
          : expenses // ignore: cast_nullable_to_non_nullable
              as String,
      benefit: null == benefit
          ? _value.benefit
          : benefit // ignore: cast_nullable_to_non_nullable
              as String,
      implementers: null == implementers
          ? _value._implementers
          : implementers // ignore: cast_nullable_to_non_nullable
              as List<ImplementsForLeanProdInfo>,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<FileElement>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MyLeanProductionsEntity implements _MyLeanProductionsEntity {
  const _$_MyLeanProductionsEntity(
      {required this.date,
      required this.number,
      required this.status,
      required this.issue,
      required this.solution,
      required this.expenses,
      required this.benefit,
      required final List<ImplementsForLeanProdInfo> implementers,
      required final List<FileElement> files})
      : _implementers = implementers,
        _files = files;

  factory _$_MyLeanProductionsEntity.fromJson(Map<String, dynamic> json) =>
      _$$_MyLeanProductionsEntityFromJson(json);

  @override
  final DateTime date;
  @override
  final String number;
  @override
  final String status;
  @override
  final String issue;
  @override
  final String solution;
  @override
  final String expenses;
  @override
  final String benefit;
  final List<ImplementsForLeanProdInfo> _implementers;
  @override
  List<ImplementsForLeanProdInfo> get implementers {
    if (_implementers is EqualUnmodifiableListView) return _implementers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_implementers);
  }

  final List<FileElement> _files;
  @override
  List<FileElement> get files {
    if (_files is EqualUnmodifiableListView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_files);
  }

  @override
  String toString() {
    return 'MyLeanProductionsEntity(date: $date, number: $number, status: $status, issue: $issue, solution: $solution, expenses: $expenses, benefit: $benefit, implementers: $implementers, files: $files)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MyLeanProductionsEntity &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.issue, issue) || other.issue == issue) &&
            (identical(other.solution, solution) ||
                other.solution == solution) &&
            (identical(other.expenses, expenses) ||
                other.expenses == expenses) &&
            (identical(other.benefit, benefit) || other.benefit == benefit) &&
            const DeepCollectionEquality()
                .equals(other._implementers, _implementers) &&
            const DeepCollectionEquality().equals(other._files, _files));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      date,
      number,
      status,
      issue,
      solution,
      expenses,
      benefit,
      const DeepCollectionEquality().hash(_implementers),
      const DeepCollectionEquality().hash(_files));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MyLeanProductionsEntityCopyWith<_$_MyLeanProductionsEntity>
      get copyWith =>
          __$$_MyLeanProductionsEntityCopyWithImpl<_$_MyLeanProductionsEntity>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MyLeanProductionsEntityToJson(
      this,
    );
  }
}

abstract class _MyLeanProductionsEntity implements MyLeanProductionsEntity {
  const factory _MyLeanProductionsEntity(
      {required final DateTime date,
      required final String number,
      required final String status,
      required final String issue,
      required final String solution,
      required final String expenses,
      required final String benefit,
      required final List<ImplementsForLeanProdInfo> implementers,
      required final List<FileElement> files}) = _$_MyLeanProductionsEntity;

  factory _MyLeanProductionsEntity.fromJson(Map<String, dynamic> json) =
      _$_MyLeanProductionsEntity.fromJson;

  @override
  DateTime get date;
  @override
  String get number;
  @override
  String get status;
  @override
  String get issue;
  @override
  String get solution;
  @override
  String get expenses;
  @override
  String get benefit;
  @override
  List<ImplementsForLeanProdInfo> get implementers;
  @override
  List<FileElement> get files;
  @override
  @JsonKey(ignore: true)
  _$$_MyLeanProductionsEntityCopyWith<_$_MyLeanProductionsEntity>
      get copyWith => throw _privateConstructorUsedError;
}

FileElement _$FileElementFromJson(Map<String, dynamic> json) {
  return _FileElement.fromJson(json);
}

/// @nodoc
mixin _$FileElement {
  @JsonKey(name: 'name')
  String get fileName => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FileElementCopyWith<FileElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FileElementCopyWith<$Res> {
  factory $FileElementCopyWith(
          FileElement value, $Res Function(FileElement) then) =
      _$FileElementCopyWithImpl<$Res, FileElement>;
  @useResult
  $Res call({@JsonKey(name: 'name') String fileName, String url});
}

/// @nodoc
class _$FileElementCopyWithImpl<$Res, $Val extends FileElement>
    implements $FileElementCopyWith<$Res> {
  _$FileElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      fileName: null == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FileElementCopyWith<$Res>
    implements $FileElementCopyWith<$Res> {
  factory _$$_FileElementCopyWith(
          _$_FileElement value, $Res Function(_$_FileElement) then) =
      __$$_FileElementCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'name') String fileName, String url});
}

/// @nodoc
class __$$_FileElementCopyWithImpl<$Res>
    extends _$FileElementCopyWithImpl<$Res, _$_FileElement>
    implements _$$_FileElementCopyWith<$Res> {
  __$$_FileElementCopyWithImpl(
      _$_FileElement _value, $Res Function(_$_FileElement) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = null,
    Object? url = null,
  }) {
    return _then(_$_FileElement(
      fileName: null == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FileElement implements _FileElement {
  const _$_FileElement(
      {@JsonKey(name: 'name') required this.fileName, required this.url});

  factory _$_FileElement.fromJson(Map<String, dynamic> json) =>
      _$$_FileElementFromJson(json);

  @override
  @JsonKey(name: 'name')
  final String fileName;
  @override
  final String url;

  @override
  String toString() {
    return 'FileElement(fileName: $fileName, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FileElement &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileName, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FileElementCopyWith<_$_FileElement> get copyWith =>
      __$$_FileElementCopyWithImpl<_$_FileElement>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FileElementToJson(
      this,
    );
  }
}

abstract class _FileElement implements FileElement {
  const factory _FileElement(
      {@JsonKey(name: 'name') required final String fileName,
      required final String url}) = _$_FileElement;

  factory _FileElement.fromJson(Map<String, dynamic> json) =
      _$_FileElement.fromJson;

  @override
  @JsonKey(name: 'name')
  String get fileName;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$_FileElementCopyWith<_$_FileElement> get copyWith =>
      throw _privateConstructorUsedError;
}

ImplementsForLeanProdInfo _$ImplementsForLeanProdInfoFromJson(
    Map<String, dynamic> json) {
  return _ImplementsForLeanProdInfo.fromJson(json);
}

/// @nodoc
mixin _$ImplementsForLeanProdInfo {
  String get name => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImplementsForLeanProdInfoCopyWith<ImplementsForLeanProdInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImplementsForLeanProdInfoCopyWith<$Res> {
  factory $ImplementsForLeanProdInfoCopyWith(ImplementsForLeanProdInfo value,
          $Res Function(ImplementsForLeanProdInfo) then) =
      _$ImplementsForLeanProdInfoCopyWithImpl<$Res, ImplementsForLeanProdInfo>;
  @useResult
  $Res call({String name, int id});
}

/// @nodoc
class _$ImplementsForLeanProdInfoCopyWithImpl<$Res,
        $Val extends ImplementsForLeanProdInfo>
    implements $ImplementsForLeanProdInfoCopyWith<$Res> {
  _$ImplementsForLeanProdInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? id = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ImplementsForLeanProdInfoCopyWith<$Res>
    implements $ImplementsForLeanProdInfoCopyWith<$Res> {
  factory _$$_ImplementsForLeanProdInfoCopyWith(
          _$_ImplementsForLeanProdInfo value,
          $Res Function(_$_ImplementsForLeanProdInfo) then) =
      __$$_ImplementsForLeanProdInfoCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, int id});
}

/// @nodoc
class __$$_ImplementsForLeanProdInfoCopyWithImpl<$Res>
    extends _$ImplementsForLeanProdInfoCopyWithImpl<$Res,
        _$_ImplementsForLeanProdInfo>
    implements _$$_ImplementsForLeanProdInfoCopyWith<$Res> {
  __$$_ImplementsForLeanProdInfoCopyWithImpl(
      _$_ImplementsForLeanProdInfo _value,
      $Res Function(_$_ImplementsForLeanProdInfo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? id = null,
  }) {
    return _then(_$_ImplementsForLeanProdInfo(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ImplementsForLeanProdInfo implements _ImplementsForLeanProdInfo {
  const _$_ImplementsForLeanProdInfo({required this.name, required this.id});

  factory _$_ImplementsForLeanProdInfo.fromJson(Map<String, dynamic> json) =>
      _$$_ImplementsForLeanProdInfoFromJson(json);

  @override
  final String name;
  @override
  final int id;

  @override
  String toString() {
    return 'ImplementsForLeanProdInfo(name: $name, id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ImplementsForLeanProdInfo &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.id, id) || other.id == id));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ImplementsForLeanProdInfoCopyWith<_$_ImplementsForLeanProdInfo>
      get copyWith => __$$_ImplementsForLeanProdInfoCopyWithImpl<
          _$_ImplementsForLeanProdInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ImplementsForLeanProdInfoToJson(
      this,
    );
  }
}

abstract class _ImplementsForLeanProdInfo implements ImplementsForLeanProdInfo {
  const factory _ImplementsForLeanProdInfo(
      {required final String name,
      required final int id}) = _$_ImplementsForLeanProdInfo;

  factory _ImplementsForLeanProdInfo.fromJson(Map<String, dynamic> json) =
      _$_ImplementsForLeanProdInfo.fromJson;

  @override
  String get name;
  @override
  int get id;
  @override
  @JsonKey(ignore: true)
  _$$_ImplementsForLeanProdInfoCopyWith<_$_ImplementsForLeanProdInfo>
      get copyWith => throw _privateConstructorUsedError;
}
